import openai
from difflib import get_close_matches


class QuestionMatcher:
    def __init__(self):
        self.api_key = "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"

    def compare_with_openai(self, question, db_questions):
        db_texts = "\n".join([f"Q{i + 1}: {qa}" for i, qa in enumerate(db_questions)])

        prompt = f"""
        Given the user's question: "{question}"

        Here is a list of potential questions:
        {db_texts}

        Find the question from the list that most closely matches the user's question in meaning, even if there are slight variations in phrasing, spelling, punctuation, or dialect. For example, if the user's question uses a different spelling or a synonym for a word in the potential questions, you should still match it. If no question from the list matches closely enough in meaning, return "none". Do not provide any other information if the meaning does not match.

        Return the question number and its content in the format "Q[number]: [content]".
        """

        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "user", "content": prompt}
            ],
            max_tokens=200,
            temperature=0.0,
            api_key=self.api_key
        )

        best_match = response.choices[0].message['content'].strip()

        if best_match.lower() == 'none':
            return None
        elif best_match.startswith('Q'):
            return best_match
        else:
            return "Unexpected output format received. Please try again."

    def compare_with_fuzzy_match(self, user_question, db_questions):
        # Create a list of questions
        questions_list = [qa for qa in db_questions]

        # Find the closest match
        closest_matches = get_close_matches(user_question, questions_list, n=1, cutoff=0.6)

        if closest_matches:
            matched_question = closest_matches[0]
            index = questions_list.index(matched_question) + 1
            return f"Q{index}: {matched_question}"
        else:
            return "none"


# Example usage
matcher = QuestionMatcher()
user_question = "??????? ??????"
db_questions = [
    "????? ????????",
    "????? ????????",
    "????? ????????",
    "?? ?? ??????? ???? ?? ??? ????????",
    "?? ?? ???? ?????? ?? ????????",
    "?? ?? ??? ?????????",
    "?? ?? ????? ????? ?????? ????? ????? ??????? ?????????",
    "?? ?? ????? ?????? ????????",
    "??? ???? ????????",
    "?? ?? ????? ????????",
    "?????? ???????????",
    "??? ??? ?????? ????????",
    "?? ?? ???? ????????",
    "?? ?? ????? ????????",
    "?????? ??????? ???????? ????????",
    "?? ?? ????? ???????? ?? ????????",
    "?? ???? ????? ??????? ????????? ?? ???? ????? ??????? ????????? ?? ?????? ???????? ?????? ??????? ?????????",
    "?? ?? ???? ????? ?? ??????? ??????? ?????????",
    "??? ???? ????? ?????",
    "???? ?????? ?? ????? ????????",
    "?? ??? ??????????",
    "??? ?? ?????? ?????? ??? ??????",
    "?????? ?????  ?",
    "?? ?????? ????? ???????",
    "?? ?? ????? ???????, ?? ?? ?????? ???? ????? ???? ???????",
    "??????",
    "????",
    "??? ??? ????? ??????? ????????",
    "??? ?????",
    "?? ???? ????? ?? ???? ????? ?? ?????? ???????? ? ?????",
    "????? ?????",
    "??? ????",
    "???? ?????",
    "???? ?????",
    "?? ?? ??????? ???????? ??????? ,?? ?? ????? ??? ????? ??????? ,?? ?? ??? ???????",
    "????",
    "?? ????",
    "?? ?? ????? ???????",
    "?? ?? ????????? ??????? ??? ???????",
    "?? ??? , ????? ?????",
    "?? ?? ??????? ????????? ???? ????? ??? ??????? , ?? ?? ?????? ??????? ???????? ???????",
    "??? ????? ???? ???????, ?? ?? ?????? ???? ??? ????",
    "?????? ?????",
    "???? ????? ??????? ?????? ? ????? ???????",
    "?? ?? ??????? ???????? ?? ???????",
    "?? ?? ??????? ???? ???? ???????? ??????? ??????",
    "?? ?? ???? ????? ?????? ????????",
    "??? ??? ????? ???????? ?????? ????????",
    "?? ?? ???? ???? ?????? ???????? ? ?? ?? ???????? ???? ?????? ????????",
    "?? ?? ???? ?????? ???????? ? ?? ?? ???????? ?????? ????????",
    "?? ?? ???????? ?????? ??????? ???? ?????? ??????? ?????? ? ???????? ?????? ???????",
    "?? ?? ???? ?????? ?????? ?????? ????? ??????? ??????????",
    "?? ?? ??????? ??????? ???? ????? ????? ??????? , ??? ??? ????? ??????? ??? ???????",
    "??? ???? ????? ????? ??????? ?????????? ,?? ?? ???? ????? ??????? , ???? ???? ????? ???????",
    "??? ???? ??????? ?????? ????? ?????? ??????? ??????? , ????? ????? ?????? ??????? ??????? ?????? ????????",
    "??? ??? ????? ?????? ??????? ???????",
    "?? ?? ??????? ??????"
]
result = matcher.compare_with_fuzzy_match(user_question, db_questions)
print(result)

